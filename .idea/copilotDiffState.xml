<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Cargo.toml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Cargo.toml" />
              <option name="originalContent" value="[package]&#10;name = &quot;mqtt&quot;&#10;version = &quot;0.1.0&quot;&#10;edition = &quot;2024&quot;&#10;&#10;[dependencies]&#10;tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }&#10;rumqttc = { version = &quot;0.24.0&quot;,features = [&quot;use-rustls&quot;] }&#10;pretty_env_logger = &quot;0.5.0&quot;&#10;log = &quot;0.4.27&quot;&#10;serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }&#10;serde_json = &quot;1.0&quot;&#10;futures = &quot;0.3&quot;&#10;chrono = { version = &quot;0.4&quot;, features = [&quot;serde&quot;] }&#10;bson = { version = &quot;2&quot;, features = [&quot;chrono-0_4&quot;] }&#10;mongodb = &quot;3&quot;&#10;dotenv = &quot;0.15&quot;&#10;axum = { version = &quot;0.8&quot; }&#10;" />
              <option name="updatedContent" value="[package]&#10;name = &quot;mqtt&quot;&#10;version = &quot;0.1.0&quot;&#10;edition = &quot;2024&quot;&#10;&#10;[dependencies]&#10;tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }&#10;rumqttc = { version = &quot;0.24.0&quot;,features = [&quot;use-rustls&quot;] }&#10;pretty_env_logger = &quot;0.5.0&quot;&#10;log = &quot;0.4.27&quot;&#10;serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }&#10;serde_json = &quot;1.0&quot;&#10;futures = &quot;0.3&quot;&#10;chrono = { version = &quot;0.4&quot;, features = [&quot;serde&quot;] }&#10;bson = { version = &quot;2&quot;, features = [&quot;chrono-0_4&quot;] }&#10;mongodb = &quot;3&quot;&#10;dotenv = &quot;0.15&quot;&#10;axum = { version = &quot;0.8&quot;, features = [&quot;ws&quot;] }&#10;tokio-tungstenite = &quot;0.21&quot;&#10;tower = &quot;0.4&quot;&#10;tower-http = { version = &quot;0.5&quot;, features = [&quot;cors&quot;] }" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/config.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/config.rs" />
              <option name="updatedContent" value="use std::env;&#10;&#10;/// 应用程序配置结构&#10;#[derive(Debug, Clone)]&#10;pub struct AppConfig {&#10;    pub mongodb_uri: String,&#10;    pub mqtt_host: String,&#10;    pub mqtt_port: u16,&#10;    pub mqtt_username: String,&#10;    pub mqtt_password: String,&#10;    pub ca_cert_path: String,&#10;}&#10;&#10;impl AppConfig {&#10;    /// 从环境变量加载配置&#10;    pub fn from_env() -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {&#10;        let mongodb_uri = env::var(&quot;MONGODB_URI&quot;)?;&#10;        let mqtt_host = env::var(&quot;MQTT_HOST&quot;)?;&#10;        let mqtt_port_str = env::var(&quot;MQTT_PORT&quot;)?;&#10;        let mqtt_port: u16 = mqtt_port_str.parse()?;&#10;        let mqtt_username = env::var(&quot;MQTT_USERNAME&quot;)?;&#10;        let mqtt_password = env::var(&quot;MQTT_PASSWORD&quot;)?;&#10;        let ca_cert_path = env::var(&quot;CA_CERT_PATH&quot;)?;&#10;&#10;        Ok(Self {&#10;            mongodb_uri,&#10;            mqtt_host,&#10;            mqtt_port,&#10;            mqtt_username,&#10;            mqtt_password,&#10;            ca_cert_path,&#10;        })&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main.rs" />
              <option name="originalContent" value="mod model;&#10;mod service;&#10;mod config;&#10;mod mqtt;&#10;mod websocket;&#10;&#10;use std::sync::Arc;&#10;use std::time::Duration;&#10;use dotenv::dotenv;&#10;use log::{error, info};&#10;use mongodb::options::ClientOptions;&#10;use mongodb::Client;&#10;use pretty_env_logger::env_logger::Env;&#10;use rumqttc::{Event, QoS};&#10;use tokio::sync::broadcast;&#10;use tokio::time::sleep;&#10;&#10;use crate::config::AppConfig;&#10;use crate::service::ship_track_service::ShipTrackService;&#10;use crate::service::flight_service::FlightService;&#10;use crate::mqtt::{create_mqtt_client, subscribe_with_retry, handle_mqtt_message};&#10;use crate::websocket::start_websocket_server;&#10;&#10;#[tokio::main]&#10;async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {&#10;    dotenv().ok();&#10;    &#10;    // 初始化日志&#10;    pretty_env_logger::formatted_builder()&#10;        .parse_env(Env::default().default_filter_or(&quot;info&quot;))&#10;        .init();&#10;    &#10;    // 加载配置&#10;    let config = AppConfig::from_env()?;&#10;    info!(&quot;配置加载成功&quot;);&#10;    &#10;    // 创建广播通道用于WebSocket推送flight消息&#10;    let (flight_tx, _) = broadcast::channel::&lt;String&gt;(100);&#10;    let flight_broadcaster = Arc::new(flight_tx);&#10;    &#10;    // 配置MongoDB连接&#10;    let client_options = ClientOptions::parse(&amp;config.mongodb_uri).await?;&#10;    let client = Client::with_options(client_options)?;&#10;    let db = client.database(&quot;shipTracking&quot;);&#10;    &#10;    // 创建服务实例&#10;    let track_collection = db.collection::&lt;model::ship_track::ShipTrack&gt;(&quot;trackSegments&quot;);&#10;    let track_service = Arc::new(ShipTrackService::new(track_collection));&#10;    &#10;    let flight_collection = db.collection::&lt;model::flight::Flight&gt;(&quot;flights&quot;);&#10;    let flight_service = Arc::new(FlightService::new(flight_collection));&#10;    &#10;    // 启动WebSocket服务器&#10;    let flight_broadcaster_clone = flight_broadcaster.clone();&#10;    tokio::spawn(async move {&#10;        if let Err(e) = start_websocket_server(flight_broadcaster_clone).await {&#10;            error!(&quot;WebSocket服务器启动失败: {}&quot;, e);&#10;        }&#10;    });&#10;    &#10;    // 创建MQTT客户端并开始主循环&#10;    run_mqtt_loop(config, track_service, flight_service, flight_broadcaster).await?;&#10;    &#10;    Ok(())&#10;}&#10;&#10;/// 运行MQTT事件循环&#10;async fn run_mqtt_loop(&#10;    config: AppConfig,&#10;    track_service: Arc&lt;ShipTrackService&gt;,&#10;    flight_service: Arc&lt;FlightService&gt;,&#10;    flight_broadcaster: Arc&lt;broadcast::Sender&lt;String&gt;&gt;,&#10;) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {&#10;    loop {&#10;        match create_mqtt_client(&#10;            &amp;config.mqtt_host,&#10;            config.mqtt_port,&#10;            &amp;config.mqtt_username,&#10;            &amp;config.mqtt_password,&#10;            &amp;config.ca_cert_path,&#10;        ).await {&#10;            Ok((mut client, mut eventloop)) =&gt; {&#10;                info!(&quot;MQTT客户端创建成功&quot;);&#10;                &#10;                // 订阅主题&#10;                subscribe_with_retry(&amp;mut client, &quot;drone/+/location&quot;, QoS::AtLeastOnce, 3).await;&#10;                subscribe_with_retry(&amp;mut client, &quot;drone/+/state&quot;, QoS::AtLeastOnce, 3).await;&#10;                &#10;                // 事件循环处理&#10;                loop {&#10;                    match eventloop.poll().await {&#10;                        Ok(event) =&gt; {&#10;                            match event {&#10;                                Event::Incoming(packet) =&gt; {&#10;                                    info!(&quot;收到消息: {:?}&quot;, packet);&#10;                                    handle_mqtt_message(&#10;                                        track_service.clone(),&#10;                                        flight_service.clone(),&#10;                                        flight_broadcaster.clone(),&#10;                                        packet&#10;                                    ).await;&#10;                                }&#10;                                Event::Outgoing(_) =&gt; {}&#10;                            }&#10;                        }&#10;                        Err(e) =&gt; {&#10;                            error!(&quot;事件循环错误: {}&quot;, e);&#10;                            break; // 跳出内层循环，重新创建客户端&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            Err(e) =&gt; {&#10;                error!(&quot;创建MQTT客户端失败: {}&quot;, e);&#10;            }&#10;        }&#10;        &#10;        error!(&quot;尝试重新连接...&quot;);&#10;        sleep(Duration::from_secs(5)).await;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="mod model;&#10;mod service;&#10;mod config;&#10;mod mqtt;&#10;mod websocket;&#10;&#10;use std::sync::Arc;&#10;use std::time::Duration;&#10;use dotenv::dotenv;&#10;use log::{error, info};&#10;use mongodb::options::ClientOptions;&#10;use mongodb::Client;&#10;use pretty_env_logger::env_logger::Env;&#10;use rumqttc::{Event, QoS};&#10;use tokio::sync::broadcast;&#10;use tokio::time::sleep;&#10;&#10;use crate::config::AppConfig;&#10;use crate::service::ship_track_service::ShipTrackService;&#10;use crate::service::flight_service::FlightService;&#10;use crate::mqtt::{create_mqtt_client, subscribe_with_retry, handle_mqtt_message};&#10;use crate::websocket::start_websocket_server;&#10;&#10;#[tokio::main]&#10;async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {&#10;    dotenv().ok();&#10;    &#10;    // 初始化日志&#10;    pretty_env_logger::formatted_builder()&#10;        .parse_env(Env::default().default_filter_or(&quot;info&quot;))&#10;        .init();&#10;    &#10;    // 加载配置&#10;    let config = AppConfig::from_env()?;&#10;    info!(&quot;配置加载成功&quot;);&#10;    &#10;    // 创建广播通道用于WebSocket推送flight消息&#10;    let (flight_tx, _) = broadcast::channel::&lt;String&gt;(100);&#10;    let flight_broadcaster = Arc::new(flight_tx);&#10;    &#10;    // 配置MongoDB连接&#10;    let client_options = ClientOptions::parse(&amp;config.mongodb_uri).await?;&#10;    let client = Client::with_options(client_options)?;&#10;    let db = client.database(&quot;shipTracking&quot;);&#10;    &#10;    // 创建服务实例&#10;    let track_collection = db.collection::&lt;model::ship_track::ShipTrack&gt;(&quot;trackSegments&quot;);&#10;    let track_service = Arc::new(ShipTrackService::new(track_collection));&#10;    &#10;    let flight_collection = db.collection::&lt;model::flight::Flight&gt;(&quot;flights&quot;);&#10;    let flight_service = Arc::new(FlightService::new(flight_collection));&#10;    &#10;    // 启动WebSocket服务器&#10;    let flight_broadcaster_clone = flight_broadcaster.clone();&#10;    tokio::spawn(async move {&#10;        start_websocket_server(flight_broadcaster_clone).await;&#10;    });&#10;    &#10;    // 创建MQTT客户端并开始主循环&#10;    run_mqtt_loop(config, track_service, flight_service, flight_broadcaster).await?;&#10;    &#10;    Ok(())&#10;}&#10;&#10;/// 运行MQTT事件循环&#10;async fn run_mqtt_loop(&#10;    config: AppConfig,&#10;    track_service: Arc&lt;ShipTrackService&gt;,&#10;    flight_service: Arc&lt;FlightService&gt;,&#10;    flight_broadcaster: Arc&lt;broadcast::Sender&lt;String&gt;&gt;,&#10;) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {&#10;    loop {&#10;        match create_mqtt_client(&#10;            &amp;config.mqtt_host,&#10;            config.mqtt_port,&#10;            &amp;config.mqtt_username,&#10;            &amp;config.mqtt_password,&#10;            &amp;config.ca_cert_path,&#10;        ).await {&#10;            Ok((mut client, mut eventloop)) =&gt; {&#10;                info!(&quot;MQTT客户端创建成功&quot;);&#10;                &#10;                // 订阅主题&#10;                subscribe_with_retry(&amp;mut client, &quot;drone/+/location&quot;, QoS::AtLeastOnce, 3).await;&#10;                subscribe_with_retry(&amp;mut client, &quot;drone/+/state&quot;, QoS::AtLeastOnce, 3).await;&#10;                &#10;                // 事件循环处理&#10;                loop {&#10;                    match eventloop.poll().await {&#10;                        Ok(event) =&gt; {&#10;                            match event {&#10;                                Event::Incoming(packet) =&gt; {&#10;                                    info!(&quot;收到消息: {:?}&quot;, packet);&#10;                                    handle_mqtt_message(&#10;                                        track_service.clone(),&#10;                                        flight_service.clone(),&#10;                                        flight_broadcaster.clone(),&#10;                                        packet&#10;                                    ).await;&#10;                                }&#10;                                Event::Outgoing(_) =&gt; {}&#10;                            }&#10;                        }&#10;                        Err(e) =&gt; {&#10;                            error!(&quot;事件循环错误: {}&quot;, e);&#10;                            break; // 跳出内层循环，重新创建客户端&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            Err(e) =&gt; {&#10;                error!(&quot;创建MQTT客户端失败: {}&quot;, e);&#10;            }&#10;        }&#10;        &#10;        error!(&quot;尝试重新连接...&quot;);&#10;        sleep(Duration::from_secs(5)).await;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/model/flight.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/model/flight.rs" />
              <option name="originalContent" value="use bson::oid::ObjectId;&#10;use serde::{Deserialize, Serialize};&#10;use mongodb::bson::serde_helpers::serialize_object_id_as_hex_string;&#10;#[derive(Debug, Serialize, Deserialize)]&#10;pub struct Flight {&#10;    #[serde(rename = &quot;_id&quot;)]&#10;    pub id: ObjectId,&#10;    #[serde(rename = &quot;trackId&quot;)]&#10;    pub track_id: ObjectId,// 关联的航迹ID&#10;    #[serde(rename = &quot;batteryCapacity&quot;)]&#10;    pub battery_capacity: Vec&lt;f64&gt;, // 电池容量&#10;    #[serde(rename = &quot;estimatedRemainingUsageTime&quot;)]&#10;    pub estimated_remaining_usage_time: Vec&lt;f64&gt;,&#10;    #[serde(rename = &quot;cabinTemperature&quot;)]&#10;    pub cabin_temperature: Vec&lt;f64&gt;,&#10;    #[serde(rename = &quot;aircraftAltitude&quot;)]&#10;    pub aircraft_altitude: Vec&lt;f64&gt;,&#10;    #[serde(rename = &quot;distanceToFan&quot;)]&#10;    pub distance_to_fan: Vec&lt;f64&gt;,&#10;}&#10;#[derive(Debug, Serialize, Deserialize, Clone)]&#10;pub struct FlightDto {&#10;    // #[serde(serialize_with = &quot;serialize_object_id_as_hex_string&quot;)]&#10;    // pub track_id: ObjectId, // 航迹ID&#10;    &#10;    pub battery_capacity: f64, // 电池容量&#10;  &#10;    pub estimated_remaining_usage_time: f64,&#10;&#10;    pub cabin_temperature: f64,&#10;&#10;    pub aircraft_altitude: f64,&#10;&#10;    pub distance_to_fan: f64,&#10;}" />
              <option name="updatedContent" value="use bson::oid::ObjectId;&#13;&#10;use serde::{Deserialize, Serialize};&#13;&#10;use mongodb::bson::serde_helpers::serialize_object_id_as_hex_string;&#13;&#10;#[derive(Debug, Serialize, Deserialize)]&#13;&#10;pub struct Flight {&#13;&#10;    #[serde(rename = &quot;_id&quot;)]&#13;&#10;    pub id: ObjectId,&#13;&#10;    #[serde(rename = &quot;trackId&quot;)]&#13;&#10;    pub track_id: ObjectId,// 关联的航迹ID&#13;&#10;    #[serde(rename = &quot;batteryCapacity&quot;)]&#13;&#10;    pub battery_capacity: Vec&lt;f64&gt;, // 电池容量&#13;&#10;    #[serde(rename = &quot;estimatedRemainingUsageTime&quot;)]&#13;&#10;    pub estimated_remaining_usage_time: Vec&lt;f64&gt;,&#13;&#10;    #[serde(rename = &quot;cabinTemperature&quot;)]&#13;&#10;    pub cabin_temperature: Vec&lt;f64&gt;,&#13;&#10;    #[serde(rename = &quot;aircraftAltitude&quot;)]&#13;&#10;    pub aircraft_altitude: Vec&lt;f64&gt;,&#13;&#10;    #[serde(rename = &quot;distanceToFan&quot;)]&#13;&#10;    pub distance_to_fan: Vec&lt;f64&gt;,&#13;&#10;}&#13;&#10;#[derive(Debug, Serialize, Deserialize, Clone)]&#13;&#10;pub struct FlightDto {&#13;&#10;    // #[serde(serialize_with = &quot;serialize_object_id_as_hex_string&quot;)]&#13;&#10;    // pub track_id: ObjectId, // 航迹ID&#13;&#10;    &#13;&#10;    pub battery_capacity: f64, // 电池容量&#13;&#10;  &#13;&#10;    pub estimated_remaining_usage_time: f64,&#13;&#10;&#13;&#10;    pub cabin_temperature: f64,&#13;&#10;&#13;&#10;    pub aircraft_altitude: f64,&#13;&#10;&#13;&#10;    pub distance_to_fan: f64,&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/mqtt/client.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/mqtt/client.rs" />
              <option name="updatedContent" value="use std::sync::Arc;&#10;use std::time::Duration;&#10;use tokio::fs::File;&#10;use tokio::io::AsyncReadExt;&#10;use tokio::time::sleep;&#10;use rumqttc::{AsyncClient, MqttOptions, QoS, TlsConfiguration, Transport};&#10;use log::{error, info, warn};&#10;&#10;/// 创建MQTT客户端配置&#10;pub async fn create_mqtt_client(&#10;    host: &amp;str,&#10;    port: u16,&#10;    username: &amp;str,&#10;    password: &amp;str,&#10;    ca_cert_path: &amp;str,&#10;) -&gt; Result&lt;(AsyncClient, rumqttc::EventLoop), Box&lt;dyn std::error::Error&gt;&gt; {&#10;    let mut mqttoptions = MqttOptions::new(username, host, port);&#10;    mqttoptions.set_credentials(username.to_string(), password.to_string());&#10;    &#10;    // 配置TLS&#10;    let mut ca_file = File::open(ca_cert_path).await?;&#10;    let mut ca = Vec::new();&#10;    ca_file.read_to_end(&amp;mut ca).await?;&#10;    mqttoptions.set_transport(Transport::Tls(TlsConfiguration::Simple {&#10;        ca,&#10;        alpn: None,&#10;        client_auth: None,&#10;    }));&#10;    mqttoptions.set_keep_alive(Duration::from_secs(5));&#10;    mqttoptions.set_clean_session(false);&#10;&#10;    let (client, eventloop) = AsyncClient::new(mqttoptions, 10);&#10;    Ok((client, eventloop))&#10;}&#10;&#10;/// 带重试的订阅函数&#10;pub async fn subscribe_with_retry(client: &amp;mut AsyncClient, topic: &amp;str, qos: QoS, max_retries: u8) {&#10;    for attempt in 1..=max_retries {&#10;        match client.subscribe(topic, qos).await {&#10;            Ok(_) =&gt; {&#10;                info!(&quot;订阅成功: {}&quot;, topic);&#10;                return;&#10;            }&#10;            Err(e) =&gt; {&#10;                warn!(&quot;第{}次订阅{}失败: {}&quot;, attempt, topic, e);&#10;                sleep(Duration::from_secs(2)).await;&#10;            }&#10;        }&#10;    }&#10;    error!(&quot;多次尝试后仍无法订阅: {}&quot;, topic);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/mqtt/handlers.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/mqtt/handlers.rs" />
              <option name="updatedContent" value="use std::sync::Arc;&#10;use tokio::sync::broadcast;&#10;use log::{error, info, warn};&#10;use serde_json;&#10;&#10;use crate::model::flight::FlightDto;&#10;use crate::service::flight_service::FlightService;&#10;use crate::service::ship_track_service::ShipTrackService;&#10;&#10;/// 处理MQTT消息的主要分发函数&#10;pub async fn handle_mqtt_message(&#10;    track_service: Arc&lt;ShipTrackService&gt;,&#10;    flight_service: Arc&lt;FlightService&gt;,&#10;    flight_broadcaster: Arc&lt;broadcast::Sender&lt;String&gt;&gt;,&#10;    packet: rumqttc::Packet,&#10;) {&#10;    match packet {&#10;        rumqttc::Packet::Publish(publish) =&gt; {&#10;            let topic = publish.topic.clone();&#10;            let payload = publish.payload.to_vec();&#10;&#10;            // 从主题中提取任务ID&#10;            let parts: Vec&lt;&amp;str&gt; = topic.split('/').collect();&#10;            if parts.len() &lt; 3 {&#10;                error!(&quot;无效的主题格式: {}&quot;, topic);&#10;                return;&#10;            }&#10;            let task_type = parts[2];&#10;            let task_id = parts[1].to_string();&#10;&#10;            match task_type {&#10;                &quot;location&quot; =&gt; {&#10;                    info!(&quot;接收到位置更新任务: {}&quot;, task_id);&#10;                    handle_location_message(track_service, task_id, payload).await;&#10;                }&#10;                &quot;state&quot; =&gt; {&#10;                    info!(&quot;接收到状态更新任务: {}&quot;, task_id);&#10;                    handle_state_message(flight_service, task_id, payload, flight_broadcaster).await;&#10;                }&#10;                _ =&gt; {&#10;                    warn!(&quot;未知任务类型: {}&quot;, task_type);&#10;                }&#10;            }&#10;        }&#10;        _ =&gt; {}&#10;    }&#10;}&#10;&#10;/// 处理flight状态消息并广播到WebSocket&#10;pub async fn handle_state_message(&#10;    flight_service: Arc&lt;FlightService&gt;,&#10;    task_id: String,&#10;    payload: Vec&lt;u8&gt;,&#10;    flight_broadcaster: Arc&lt;broadcast::Sender&lt;String&gt;&gt;,&#10;) {&#10;    // 解析消息内容&#10;    match serde_json::from_slice::&lt;FlightDto&gt;(&amp;payload) {&#10;        Ok(state) =&gt; {&#10;            info!(&quot;handle_state_message:{:?}&quot;, state);&#10;            if let Err(e) = flight_service.get(&amp;task_id).await {&#10;                error!(&quot;获取航行报告任务失败: {:?}&quot;, e);&#10;                return;&#10;            }&#10;            match flight_service.append_data_and_update(&amp;task_id, state.clone()).await {&#10;                Ok(_) =&gt; {&#10;                    info!(&quot;航行报告消息处理成功: {}&quot;, task_id);&#10;                    &#10;                    // 创建包含task_id的完整消息结构&#10;                    let flight_message = serde_json::json!({&#10;                        &quot;task_id&quot;: task_id,&#10;                        &quot;data&quot;: state&#10;                    });&#10;                    &#10;                    // 将消息广播到所有WebSocket连接&#10;                    if let Ok(json_str) = serde_json::to_string(&amp;flight_message) {&#10;                        if let Err(e) = flight_broadcaster.send(json_str) {&#10;                            warn!(&quot;广播flight消息失败: {}&quot;, e);&#10;                        } else {&#10;                            info!(&quot;已广播flight消息到WebSocket客户端&quot;);&#10;                        }&#10;                    }&#10;                }&#10;                Err(e) =&gt; warn!(&quot;航行报告消息处理失败: {}&quot;, e),&#10;            }&#10;        }&#10;        Err(e) =&gt; {&#10;            error!(&quot;解析任务消息失败: {}&quot;, e);&#10;        }&#10;    }&#10;}&#10;&#10;/// 处理位置消息&#10;pub async fn handle_location_message(&#10;    db_service: Arc&lt;ShipTrackService&gt;,&#10;    task_id: String,&#10;    payload: Vec&lt;u8&gt;,&#10;) {&#10;    // 解析消息内容&#10;    match serde_json::from_slice::&lt;Vec&lt;[f64;2]&gt;&gt;(&amp;payload) {&#10;        Ok(task) =&gt; {&#10;            info!(&quot;taskid: {} ,longitude: {},and latitude: {}&quot;, task_id, task[0][0], task[0][1]);&#10;            if let Err(e) = db_service.get(&amp;task_id).await {&#10;                error!(&quot;获取位置任务失败: {:?}&quot;, e);&#10;                return;&#10;            }&#10;            match db_service.append_coordinates_and_update(&amp;task_id, task).await {&#10;                Ok(_) =&gt; info!(&quot;任务消息处理成功: {}&quot;, task_id),&#10;                Err(e) =&gt; warn!(&quot;任务消息处理失败: {}&quot;, e),&#10;            }&#10;        }&#10;        Err(e) =&gt; {&#10;            error!(&quot;解析任务消息失败: {}&quot;, e);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/mqtt/mod.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/mqtt/mod.rs" />
              <option name="updatedContent" value="pub mod client;&#10;pub mod handlers;&#10;&#10;pub use client::*;&#10;pub use handlers::*;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/websocket/handler.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/websocket/handler.rs" />
              <option name="originalContent" value="use std::sync::Arc;&#10;use axum::extract::ws::{Message, WebSocket};&#10;use tokio::sync::broadcast;&#10;use futures::{sink::SinkExt, stream::StreamExt};&#10;use log::info;&#10;&#10;/// 处理WebSocket连接&#10;pub async fn handle_websocket(socket: WebSocket, flight_broadcaster: Arc&lt;broadcast::Sender&lt;String&gt;&gt;) {&#10;    let (mut sender, mut receiver) = socket.split();&#10;    let mut flight_rx = flight_broadcaster.subscribe();&#10;    &#10;    info!(&quot;新的WebSocket连接已建立&quot;);&#10;&#10;    // 创建一个任务来处理从广播通道接收消息并发送到WebSocket&#10;    let mut send_task = tokio::spawn(async move {&#10;        while let Ok(msg) = flight_rx.recv().await {&#10;            if sender.send(Message::Text(msg.into())).await.is_err() {&#10;                info!(&quot;WebSocket发送失败，连接可能已断开&quot;);&#10;                break;&#10;            }&#10;        }&#10;        info!(&quot;发送任务结束&quot;);&#10;    });&#10;&#10;    // 创建一个任务来处理从WebSocket接收消息（用于保持连接和心跳检测）&#10;    let mut recv_task = tokio::spawn(async move {&#10;        while let Some(msg) = receiver.next().await {&#10;            match msg {&#10;                Ok(msg) =&gt; {&#10;                    match msg {&#10;                        Message::Text(text) =&gt; {&#10;                            info!(&quot;收到WebSocket消息: {}&quot;, text);&#10;                            // 这里可以处理客户端发送的消息，但不结束任务&#10;                        }&#10;                        Message::Binary(_) =&gt; {&#10;                            info!(&quot;收到WebSocket二进制消息&quot;);&#10;                        }&#10;                        Message::Ping(payload) =&gt; {&#10;                            info!(&quot;收到WebSocket Ping消息&quot;);&#10;                            // Axum会自动处理Ping/Pong，这里只是记录&#10;                        }&#10;                        Message::Pong(_) =&gt; {&#10;                            info!(&quot;收到WebSocket Pong消息&quot;);&#10;                        }&#10;                        Message::Close(_) =&gt; {&#10;                            info!(&quot;收到WebSocket关闭消息&quot;);&#10;                            break;&#10;                        }&#10;                    }&#10;                }&#10;                Err(e) =&gt; {&#10;                    info!(&quot;WebSocket接收消息出错: {}&quot;, e);&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;        info!(&quot;接收任务结束&quot;);&#10;    });&#10;&#10;    // 等待任一任务完成（通常是因为连接断开）&#10;    tokio::select! {&#10;        _ = &amp;mut send_task =&gt; {&#10;            info!(&quot;发送任务完成，正在终止接收任务&quot;);&#10;            recv_task.abort();&#10;        },&#10;        _ = &amp;mut recv_task =&gt; {&#10;            info!(&quot;接收任务完成，正在终止发送任务&quot;);&#10;            send_task.abort();&#10;        }&#10;    }&#10;&#10;    info!(&quot;WebSocket连接已断开&quot;);&#10;}&#10;" />
              <option name="updatedContent" value="use std::sync::Arc;&#10;use axum::extract::ws::{Message, WebSocket};&#10;use tokio::sync::broadcast;&#10;use futures::{sink::SinkExt, stream::StreamExt};&#10;use log::info;&#10;&#10;/// 处理WebSocket连接&#10;pub async fn handle_websocket(socket: WebSocket, flight_broadcaster: Arc&lt;broadcast::Sender&lt;String&gt;&gt;) {&#10;    let (mut sender, mut receiver) = socket.split();&#10;    let mut flight_rx = flight_broadcaster.subscribe();&#10;    &#10;    info!(&quot;新的WebSocket连接已建立&quot;);&#10;&#10;    // 创建一个任务来处理从广播通道接收消息并发送到WebSocket&#10;    let mut send_task = tokio::spawn(async move {&#10;        while let Ok(msg) = flight_rx.recv().await {&#10;            if sender.send(Message::Text(msg.into())).await.is_err() {&#10;                info!(&quot;WebSocket发送失败，连接已断开&quot;);&#10;                break;&#10;            }&#10;        }&#10;        info!(&quot;发送任务结束 - 可能是广播通道关闭或连接断开&quot;);&#10;    });&#10;&#10;    // 创建一个任务来处理从WebSocket接收消息（用于保持连接和心跳检测）&#10;    let mut recv_task = tokio::spawn(async move {&#10;        while let Some(msg) = receiver.next().await {&#10;            match msg {&#10;                Ok(msg) =&gt; {&#10;                    match msg {&#10;                        Message::Text(text) =&gt; {&#10;                            info!(&quot;收到WebSocket消息: {}&quot;, text);&#10;                            // 这里可以处理客户端发送的消息，但不结束任务&#10;                        }&#10;                        Message::Binary(_) =&gt; {&#10;                            info!(&quot;收到WebSocket二进制消息&quot;);&#10;                        }&#10;                        Message::Ping(_) =&gt; {&#10;                            info!(&quot;收到WebSocket Ping消息&quot;);&#10;                            // Axum会自动处理Ping/Pong，这里只是记录&#10;                        }&#10;                        Message::Pong(_) =&gt; {&#10;                            info!(&quot;收到WebSocket Pong消息&quot;);&#10;                        }&#10;                        Message::Close(_) =&gt; {&#10;                            info!(&quot;收到WebSocket关闭消息，客户端主动断开连接&quot;);&#10;                            break;&#10;                        }&#10;                    }&#10;                }&#10;                Err(e) =&gt; {&#10;                    info!(&quot;WebSocket接收消息出错，连接异常断开: {}&quot;, e);&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;        info!(&quot;接收任务结束 - 连接已断开&quot;);&#10;    });&#10;&#10;    // 等待任一任务完成，这通常意味着连接已断开&#10;    tokio::select! {&#10;        _ = &amp;mut send_task =&gt; {&#10;            info!(&quot;发送任务完成，可能是连接断开或广播通道关闭&quot;);&#10;            // 如果发送任务结束，说明连接可能已断开，终止接收任务&#10;            recv_task.abort();&#10;        },&#10;        _ = &amp;mut recv_task =&gt; {&#10;            info!(&quot;接收任务完成，客户端已断开连接&quot;);&#10;            // 如果接收任务结束，说明客户端断开了连接，终止发送任务&#10;            send_task.abort();&#10;        }&#10;    }&#10;&#10;    info!(&quot;WebSocket连接已断开&quot;);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/websocket/mod.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/websocket/mod.rs" />
              <option name="originalContent" value="pub mod server;&#10;pub mod handler;&#10;&#10;pub use server::start_websocket_server;&#10;pub use handler::*;&#10;" />
              <option name="updatedContent" value="pub mod server;&#10;pub mod handler;&#10;&#10;pub use server::start_websocket_server;&#10;pub use handler::handle_websocket;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/websocket/server.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/websocket/server.rs" />
              <option name="originalContent" value="use std::sync::Arc;&#10;use axum::{&#10;    extract::{ws::WebSocketUpgrade, State},&#10;    response::Response,&#10;    routing::get,&#10;    Router,&#10;};&#10;use tokio::sync::broadcast;&#10;use tower_http::cors::CorsLayer;&#10;use log::info;&#10;&#10;use super::handler::handle_websocket;&#10;&#10;/// 启动WebSocket服务器&#10;pub async fn start_websocket_server(flight_broadcaster: Arc&lt;broadcast::Sender&lt;String&gt;&gt;) {&#10;    let app = Router::new()&#10;        .route(&quot;/flight_ws&quot;, get(websocket_handler))&#10;        .layer(CorsLayer::permissive())&#10;        .with_state(flight_broadcaster);&#10;&#10;    let listener = tokio::net::TcpListener::bind(&quot;0.0.0.0:8080&quot;).await.unwrap();&#10;    info!(&quot;WebSocket服务器启动在 ws://0.0.0.0:8080/flight_ws&quot;);&#10;    &#10;    axum::serve(listener, app).await.unwrap();&#10;}&#10;&#10;/// WebSocket升级处理器&#10;async fn websocket_handler(&#10;    ws: WebSocketUpgrade,&#10;    State(flight_broadcaster): State&lt;Arc&lt;broadcast::Sender&lt;String&gt;&gt;&gt;,&#10;) -&gt; Response {&#10;    ws.on_upgrade(|socket| handle_websocket(socket, flight_broadcaster))&#10;}&#10;" />
              <option name="updatedContent" value="use std::sync::Arc;&#10;use axum::{&#10;    extract::{ws::WebSocketUpgrade, State},&#10;    response::Response,&#10;    routing::get,&#10;    Router,&#10;};&#10;use tokio::sync::broadcast;&#10;use tower_http::cors::CorsLayer;&#10;use log::info;&#10;&#10;use super::handle_websocket;&#10;&#10;/// 启动WebSocket服务器&#10;pub async fn start_websocket_server(flight_broadcaster: Arc&lt;broadcast::Sender&lt;String&gt;&gt;) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {&#10;    let app = Router::new()&#10;        .route(&quot;/flight_ws&quot;, get(websocket_handler))&#10;        .layer(CorsLayer::permissive())&#10;        .with_state(flight_broadcaster);&#10;&#10;    let listener = tokio::net::TcpListener::bind(&quot;0.0.0.0:8080&quot;).await?;&#10;    info!(&quot;WebSocket服务器启动在 ws://0.0.0.0:8080/flight_ws&quot;);&#10;    &#10;    axum::serve(listener, app).await?;&#10;    Ok(())&#10;}&#10;&#10;/// WebSocket升级处理器&#10;async fn websocket_handler(&#10;    ws: WebSocketUpgrade,&#10;    State(flight_broadcaster): State&lt;Arc&lt;broadcast::Sender&lt;String&gt;&gt;&gt;,&#10;) -&gt; Response {&#10;    ws.on_upgrade(|socket| handle_websocket(socket, flight_broadcaster))&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>